from time import sleepfrom setup import *import TurnModule# core codedef go(leftSpeed, rightSpeed):    '''    직진을 위한 양쪽 모터 스피드를 설정    :param leftSpeed: 왼쪽 모터 스피드    :param rightSpeed: 오른쪽 모터 스피드    :return: None    '''    LeftPwm.start(leftSpeed * 2.4)    RightPwm.start(rightSpeed * 2.4)def stop():    '''    양쪽 모터의 스피드를 0으로 설정해 모터를 정지시킨다.    :return: None    '''    LeftPwm.ChangeDutyCycle(0)    RightPwm.ChangeDutyCycle(0)check = Falsego(0, 0)result = [    ['01111', 26, 8, 1],    ['00111', 20, 9, 1],    ['00011', 23, 10.5, 1],    ['10111', 23, 11, 1],    ['10011', 23, 16, 1],    ['11110', 8, 29, -1],    ['11100', 9, 25, -1],    ['11000', 10.5, 25, -1],    ['11101', 11, 25, -1],    ['11001', 16, 25, -1],    ['11011', 22, 22, -1],    ['10001', 22, 22, -1],]direction = 0loop = 0avoid_check = Falsemaze_check = Falseold_sensor = ["1", "1", "1", "1", "1"]old_check = Falseturn_left = 48turn_right = 48try:    while True:        sensor = [str(GPIO.input(x)) for x in senser_pin]        print(sensor)        if old_check and sensor[4] == "1" and sensor[3] == "1" and not avoid_check and not maze_check:            old_check = False            go(18, 18)            sleep(0.3)            TurnModule.pointTurn(43, "right")            print("right")            maze_check = True            old_sensor = ["1", "1", "1", "1", "1"]            direction = 1            GPIO.output(motor_pin["left"][2], GPIO.HIGH)            GPIO.output(motor_pin["right"][2], GPIO.HIGH)            while True:                temp_sensor = [str(GPIO.input(x)) for x in senser_pin]                print("right:", temp_sensor)                if "".join(temp_sensor) == "11111":                    break                sleep(0.05)            continue        elif not old_check and sensor[4] == "0" and sensor[3] == "0":            old_check = True        if "".join(sensor) == "11111" and not maze_check and not avoid_check:            print("error")            go(18, 18)            sleep(0.2)            if direction == -1:                TurnModule.pointTurn(48, "right")                direction = 1            elif direction == 1:                TurnModule.pointTurn(48, "left")                direction = -1            avoid_check = True            GPIO.output(motor_pin["left"][2], GPIO.HIGH)            GPIO.output(motor_pin["right"][2], GPIO.HIGH)            continue        elif "".join(sensor) == "11111" and (maze_check or avoid_check):            while True:                temp_check = False                temp_sensor = [str(GPIO.input(x)) for x in senser_pin]                for i in temp_sensor:                    if i == "0":                        temp_check = True                        break                if temp_check:                    break                stop()                sleep(0.3)                if direction == -1:                    TurnModule.pointTurn(48, "left")                elif direction == 1:                    TurnModule.pointTurn(48, "right")                sleep(0.2)        inputStream = "".join(sensor)        for idx in range(len(result)):            if inputStream == result[idx][0]:                if not avoid_check or not maze_check:                    old_check = False                avoid_check = False                maze_check = False                TurnModule.motorSet(False, "left")                TurnModule.motorSet(False, "right")                print(result[idx])                go(result[idx][2], result[idx][1])                direction = result[idx][3]                break        old_sensor = sensor        sleep(0.05)except KeyboardInterrupt:    GPIO.output(motor_pin["left"][2], GPIO.LOW)    GPIO.output(motor_pin["right"][2], GPIO.LOW)    LeftPwm.ChangeDutyCycle(0)    RightPwm.ChangeDutyCycle(0)    GPIO.cleanup()